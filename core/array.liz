dyn_array: struct(T)
{
	data : *T,
	count : u64,
	cap : u64,
	alloc : *mem_alloc,
}
it_start::fn{T}(dyn : *dyn_array(T)) ! *T
{
	return (*dyn)[0];
}
it_end::fn{T}(dyn : *dyn_array(T)) ! *T
{
	return ptr_offset(dyn.data, dyn.count, T);
}
operator []{ T }(dyn : *dyn_array(T), idx : u64) !*T
{
	ASSERT(idx < dyn.count);
	return ptr_offset(dyn.data, idx, T);
}
dyn_clear::fn{ T }(dyn : *dyn_array(T))
{
	dyn.count = 0;
}
dyn_init::fn{ T }(dyn : *dyn_array(T), cap : u64)
{
	dyn.data = cast(*T)heap_alloc(dyn.alloc, cast(u32)(cap * sizeof(T)));
	dyn.count = 0;
	dyn.cap = cap;
}
regrow::fn{ T }(dyn : *dyn_array(T), sz : u64)
{
	if ((dyn.count + sz) >= dyn.cap)
	{
		aux_data: = dyn.data;
		dyn.cap = dyn.cap * 2;
		dyn.data = heap_alloc(dyn.alloc, cast(u32)dyn.cap * sizeof(T));
		memcpy(cast(*void)dyn.data, cast(*void)aux_data, dyn.count * sizeof(T));
	}
	else
		dyn.count = dyn.count + sz;
}
dyn_add::fn{ T }(dyn : *dyn_array(T), data : *T)
{
	ASSERT(dyn.cap > 0 && dyn.alloc != nil);

	if (dyn.count + 1) >= dyn.cap
	{
		aux_data: = dyn.data;
		dyn.cap = dyn.cap * 2;
		heap_free(dyn.alloc, cast(*u8)aux_data);
		dyn.data = heap_alloc(dyn.alloc, cast(u32)dyn.cap * sizeof(T));
		memcpy(cast(*void)dyn.data, cast(*void)aux_data, dyn.count * sizeof(T));
	}

	dst: = cast(*void)(cast(u64)dyn.data + dyn.count * sizeof(T));
	memcpy(dst, cast(*void)data, sizeof(T));

	dyn.count += 1;
}
str_cmp::fn(a :str_lit, b : str_lit) !bool
{
	l1 := str_ln(a);
	l2 := str_ln(b);

	if l1 != l2
		return false;

	for i in 0..l1
	{
		if *ptr_offset(a, cast(u64)i, u8) != *ptr_offset(b, cast(u64)i, u8)
			return false;
	}
	return true;
}
str_ln::fn(str :str_lit) !u64
{
	s: = cast(*u8)str;
	
	i:u64 = 0;
	while *ptr_offset(s, i, u8) != 0
	{
		i++;
	}
	return i;
}
